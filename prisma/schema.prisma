// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  ADMIN
  OPERATOR
  READ_ONLY
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?

  role     UserRole @default(OPERATOR)
  isActive Boolean  @default(true)

  passwordHash String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accounts  Account[]
  sessions  Session[]
  auditLogs AuditLog[]

  // Nuevo: Notas de venta creadas por este usuario
  salesNotesCreated SalesNote[] @relation("SalesNoteCreatedBy")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// ----------------------------
// Core business models
// ----------------------------

// PartyRoleType models what a "Party" is for the business.
// A Party can be a CUSTOMER, a SUPPLIER, or both (via PartyRole join table).
enum PartyRoleType {
  CUSTOMER
  SUPPLIER
}

// Sales notes are the "real" sale documents that can affect money movements.
// A SalesNote will be reflected in PartyLedgerEntry as RECEIVABLE (customer owes).
enum SalesNoteStatus {
  DRAFT
  CONFIRMED
  CANCELLED
}

// Payments represent money movement events.
// - IN: customer pays the business
// - OUT: business pays a supplier (or money out in general)
enum PaymentDirection {
  IN
  OUT
}

// PaymentType is used both for IN and OUT.
// NOTE: UI should map EXCHANGE to "Al cambio".
enum PaymentType {
  CASH
  TRANSFER
  CREDIT
  EXCHANGE // Al cambio
}

// PartyLedgerEntry is a derived accounting-style ledger per Party.
// It tracks how much the party owes us (RECEIVABLE) or we owe them (PAYABLE).
enum PartyLedgerSide {
  RECEIVABLE
  PAYABLE
}

// PartyLedgerSourceType describes what generated the ledger movement.
// IMPORTANT: Ledger entries are derived from source documents.
// We enforce 1 entry per source (see @@unique([sourceType, sourceId])).
enum PartyLedgerSourceType {
  SALES_NOTE
  SUPPLIER_PURCHASE
  PAYMENT
  ADJUSTMENT
}

// Quotations are commercial offers/quotes; they do NOT directly generate ledger entries.
// They can be converted later to a SalesNote.
// Typical lifecycle: DRAFT -> SENT -> CONVERTED/CANCELLED.
enum QuotationStatus {
  DRAFT
  SENT
  CONVERTED
  CANCELLED
}

// FolioType is used for sequential monthly folios.
// Each type has its own independent sequence per year+month.
// Example: SALES_NOTE uses FolioType.SALES_NOTE, Quotation uses FolioType.QUOTATION.
enum FolioType {
  SALES_NOTE
  QUOTATION
}

// ----------------------------
// Audit log (money  traceability)
// ----------------------------

enum AuditEntityType {
  SALES_NOTE
  SUPPLIER_PURCHASE
  PAYMENT
}

enum AuditAction {
  CREATE
  UPDATE
}

enum AuditChangeKey {
  // Sales note totals
  SALES_NOTE_SUBTOTAL
  SALES_NOTE_DISCOUNT_TOTAL
  SALES_NOTE_TOTAL
  SALES_NOTE_BALANCE_DUE

  // Supplier purchase totals
  SUPPLIER_PURCHASE_TOTAL
  SUPPLIER_PURCHASE_BALANCE_DUE

  // Payment
  PAYMENT_AMOUNT
  PAYMENT_OCCURRED_AT
}

model Party {
  id String @id @default(cuid())

  // systemKey is reserved for special system parties (e.g. walk-in public).
  // It must be unique if present.
  systemKey String? @unique

  // Main contact identification
  name  String
  phone String?
  notes String?

  createdAt DateTime  @default(now())
  updatedAt DateTime?

  // Soft-delete so we can preserve references and historical documents.
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  // Roles are modeled via PartyRole (many-to-many-ish over a single Party).
  // A Party can be both customer and supplier.
  roles PartyRole[]

  // Document relations (history)
  salesNotes        SalesNote[]
  payments          Payment[]
  supplierPurchases SupplierPurchase[]
  quotations        Quotation[]

  // Derived ledger entries (accounting projection)
  ledgerEntries PartyLedgerEntry[]

  @@index([name])
}

model PartyRole {
  id      String        @id @default(cuid())
  partyId String
  role    PartyRoleType

  party Party @relation(fields: [partyId], references: [id], onDelete: Cascade)

  // A party cannot have duplicated roles.
  @@unique([partyId, role])
  // Useful for filtering customers vs suppliers.
  @@index([role])
}

model ProductVariant {
  id String @id @default(cuid())

  // Minimal product identification.
  // This is used to build descriptionSnapshot in documents.
  speciesName String
  variantName String?
  bagSize     String?
  color       String?

  // Base price reference (not necessarily the final sale price).
  defaultPrice Decimal @db.Decimal(18, 2)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft-delete for catalog integrity.
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  // Lines reference product variants, but can be nullable to support "external items"
  // or preserve historical documents if the variant is deleted later.
  salesNoteLines SalesNoteLine[]
  quotationLines QuotationLine[]

  @@index([speciesName, variantName])
  @@index([isDeleted])
}

model SalesNote {
  id String @id @default(cuid())

  folio String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Nuevo: Usuario que creó la nota
  createdByUserId String?
  createdBy       User?   @relation("SalesNoteCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  partyId String
  party   Party  @relation(fields: [partyId], references: [id], onDelete: Restrict)

  status SalesNoteStatus @default(DRAFT)

  subtotal      Decimal @db.Decimal(18, 2)
  discountTotal Decimal @db.Decimal(18, 2)
  total         Decimal @db.Decimal(18, 2)

  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  lines    SalesNoteLine[]
  payments Payment[]

  @@index([partyId])
  @@index([createdAt])
  @@index([status])
  @@index([isDeleted])
  @@index([createdByUserId]) // Nuevo índice
}

model SalesNoteLine {
  id          String @id @default(cuid())
  salesNoteId String

  // Optional: allows unregistered/external products or historic preservation after deletion.
  productVariantId String?

  // Snapshot of the item description at the time of sale.
  // IMPORTANT: do not depend on ProductVariant current name for historical views.
  descriptionSnapshot String

  // Decimal quantity supports partial units/weights.
  quantity Decimal @db.Decimal(18, 3)

  // Unit price and line total are stored to preserve pricing at time of transaction.
  unitPrice Decimal @db.Decimal(18, 2)
  lineTotal Decimal @db.Decimal(18, 2)

  salesNote      SalesNote       @relation(fields: [salesNoteId], references: [id], onDelete: Cascade)
  productVariant ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: SetNull)

  @@index([salesNoteId])
  @@index([productVariantId])
}

model Payment {
  id String @id @default(cuid())

  salesNoteId String?
  salesNote   SalesNote? @relation(fields: [salesNoteId], references: [id], onDelete: SetNull)

  supplierPurchaseId String?
  supplierPurchase   SupplierPurchase? @relation(fields: [supplierPurchaseId], references: [id], onDelete: SetNull)

  partyId String?
  party   Party?  @relation(fields: [partyId], references: [id], onDelete: SetNull)

  direction   PaymentDirection
  paymentType PaymentType

  amount Decimal? @db.Decimal(18, 2)

  reference String?
  notes     String?

  occurredAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft-delete para preservar historial financiero
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  @@index([salesNoteId])
  @@index([partyId])
  @@index([supplierPurchaseId])
  @@index([occurredAt])
  @@index([isDeleted])
}

model SupplierPurchase {
  id String @id @default(cuid())

  partyId String

  supplierFolio String

  occurredAt DateTime

  total Decimal @db.Decimal(18, 2)

  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft-delete para preservar referencias y documentos históricos
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  party    Party     @relation(fields: [partyId], references: [id], onDelete: Restrict)
  payments Payment[]

  @@index([partyId])
  @@index([occurredAt])
  @@index([isDeleted])
}

model PartyLedgerEntry {
  id      String @id @default(cuid())
  partyId String

  side PartyLedgerSide

  sourceType PartyLedgerSourceType

  sourceId String?

  reference String

  occurredAt DateTime

  amount Decimal @db.Decimal(18, 2)

  notes     String?
  createdAt DateTime @default(now())

  // Soft-delete para preservar integridad del ledger histórico
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  party Party @relation(fields: [partyId], references: [id], onDelete: Cascade)

  @@unique([sourceType, sourceId])
  @@index([partyId])
  @@index([occurredAt])
  @@index([sourceType, sourceId])
  @@index([isDeleted])
}

model Quotation {
  id String @id @default(cuid())

  // Human-friendly unique folio (generated using FolioSequence type QUOTATION).
  // IMPORTANT: Quotations do NOT generate ledger entries directly.
  folio String @unique

  // Contact/party for the quotation (customer or lead stored as Party).
  partyId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status QuotationStatus @default(DRAFT)

  // Total can be stored to optimize reads; should be kept consistent with lines.
  // Nullable to allow drafts during migration; business logic should compute it.
  total Decimal? @db.Decimal(18, 2)

  // Soft-delete para preservar referencias y documentos históricos
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  party Party @relation(fields: [partyId], references: [id], onDelete: Restrict)

  // Quotation owns its lines; deleting quotation deletes lines.
  lines QuotationLine[]

  @@index([partyId])
  @@index([createdAt])
  @@index([status])
  @@index([isDeleted])
}

model QuotationLine {
  id          String @id @default(cuid())
  quotationId String

  // Optional, supports external/manual line items or historical preservation.
  productVariantId String?

  // Snapshot of the item description at the time of quoting.
  descriptionSnapshot String

  quantity Decimal @db.Decimal(18, 3)

  // Quoted unit price (does not have to match ProductVariant.defaultPrice).
  quotedUnitPrice Decimal @db.Decimal(18, 2)

  quotation      Quotation       @relation(fields: [quotationId], references: [id], onDelete: Cascade)
  productVariant ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: SetNull)

  @@index([quotationId])
  @@index([productVariantId])
}

model FolioSequence {
  id String @id @default(cuid())

  // Folio type (e.g. SALES_NOTE, QUOTATION)
  type FolioType

  // Sequence is partitioned by year and month to keep folios readable and reset monthly.
  year  Int
  month Int

  // Next number to use within (type, year, month)
  nextNumber Int

  // Ensures there is a single sequence row per month per folio type.
  @@unique([type, year, month])
}

// ----------------------------
// Audit log (append-only events  typed before/after changes)
// ----------------------------

model AuditLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Optional actor (works even if some flows don't pass user context yet).
  actorUserId       String?
  actorUser         User?     @relation(fields: [actorUserId], references: [id], onDelete: SetNull)
  actorNameSnapshot String?
  actorRoleSnapshot UserRole?

  action   AuditAction
  eventKey String

  // The entity directly affected by the event
  entityType AuditEntityType
  entityId   String

  // Timeline grouping (always SalesNote or SupplierPurchase)
  rootEntityType AuditEntityType
  rootEntityId   String

  // Helpful UI info (folio, supplierFolio, bank reference, etc.)
  reference  String?
  occurredAt DateTime?

  // Free-form extra info (traceId, line summary, etc.)
  meta Json?

  changes AuditLogChange[]

  @@index([rootEntityType, rootEntityId, createdAt])
  @@index([entityType, entityId, createdAt])
  @@index([eventKey, createdAt])
  @@index([actorUserId, createdAt])
}

model AuditLogChange {
  id         String @id @default(cuid())
  auditLogId String

  key AuditChangeKey

  decimalBefore Decimal? @db.Decimal(18, 2)
  decimalAfter  Decimal? @db.Decimal(18, 2)

  stringBefore String?
  stringAfter  String?

  jsonBefore Json?
  jsonAfter  Json?

  auditLog AuditLog @relation(fields: [auditLogId], references: [id], onDelete: Cascade)

  @@index([auditLogId])
  @@index([key])
}
