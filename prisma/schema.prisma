// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum UserRole {
  ADMIN
  OPERATOR
  READ_ONLY
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?

  role     UserRole @default(OPERATOR)
  isActive Boolean  @default(true)

  passwordHash String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accounts Account[]
  sessions Session[]
}


model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// ----------------------------
// Core business models
// ----------------------------

// PartyRoleType models what a "Party" is for the business.
// A Party can be a CUSTOMER, a SUPPLIER, or both (via PartyRole join table).
enum PartyRoleType {
  CUSTOMER
  SUPPLIER
}

// Sales notes are the "real" sale documents that can affect money movements.
// A SalesNote will be reflected in PartyLedgerEntry as RECEIVABLE (customer owes).
enum SalesNoteStatus {
  DRAFT
  CONFIRMED
  CANCELLED
}

// Payments represent money movement events.
// - IN: customer pays the business
// - OUT: business pays a supplier (or money out in general)
enum PaymentDirection {
  IN
  OUT
}

// PaymentType is used both for IN and OUT.
// NOTE: UI should map EXCHANGE to "Al cambio".
enum PaymentType {
  CASH
  TRANSFER
  CREDIT
  EXCHANGE // Al cambio
}

// Audit logging entity types
enum AuditEntityType {
  SALES_NOTE
  PAYMENT
  SUPPLIER_PURCHASE
}

// Audit logging action types
enum AuditAction {
  CREATE
  UPDATE
}

// Audit logging change keys
enum AuditChangeKey {
  SALES_NOTE_SUBTOTAL
  SALES_NOTE_DISCOUNT_TOTAL
  SALES_NOTE_TOTAL
  SALES_NOTE_BALANCE_DUE
  PAYMENT_AMOUNT
  SUPPLIER_PURCHASE_TOTAL
  SUPPLIER_PURCHASE_BALANCE_DUE
}

// PartyLedgerEntry is a derived accounting-style ledger per Party.
// It tracks how much the party owes us (RECEIVABLE) or we owe them (PAYABLE).
enum PartyLedgerSide {
  RECEIVABLE
  PAYABLE
}

// PartyLedgerSourceType describes what generated the ledger movement.
// IMPORTANT: Ledger entries are derived from source documents.
// We enforce 1 entry per source (see @@unique([sourceType, sourceId])).
enum PartyLedgerSourceType {
  SALES_NOTE
  SUPPLIER_PURCHASE
  PAYMENT
  ADJUSTMENT
}

// Quotations are commercial offers/quotes; they do NOT directly generate ledger entries.
// They can be converted later to a SalesNote.
// Typical lifecycle: DRAFT -> SENT -> CONVERTED/CANCELLED.
enum QuotationStatus {
  DRAFT
  SENT
  CONVERTED
  CANCELLED
}

// FolioType is used for sequential monthly folios.
// Each type has its own independent sequence per year+month.
// Example: SALES_NOTE uses FolioType.SALES_NOTE, Quotation uses FolioType.QUOTATION.
enum FolioType {
  SALES_NOTE
  QUOTATION
}

model Party {
  id        String   @id @default(cuid())

  // systemKey is reserved for special system parties (e.g. walk-in public).
  // It must be unique if present.
  systemKey String?  @unique

  // Main contact identification
  name      String
  phone     String?
  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime?

  // Soft-delete so we can preserve references and historical documents.
  isDeleted Boolean  @default(false)
  deletedAt DateTime?

  // Roles are modeled via PartyRole (many-to-many-ish over a single Party).
  // A Party can be both customer and supplier.
  roles     PartyRole[]

  // Document relations (history)
  salesNotes SalesNote[]
  payments  Payment[]
  supplierPurchases SupplierPurchase[]
  quotations Quotation[]

  // Derived ledger entries (accounting projection)
  ledgerEntries PartyLedgerEntry[]

  @@index([name])
}

model PartyRole {
  id      String        @id @default(cuid())
  partyId String
  role    PartyRoleType

  party Party @relation(fields: [partyId], references: [id], onDelete: Cascade)

  // A party cannot have duplicated roles.
  @@unique([partyId, role])

  // Useful for filtering customers vs suppliers.
  @@index([role])
}

model ProductVariant {
  id           String   @id @default(cuid())

  // Minimal product identification.
  // This is used to build descriptionSnapshot in documents.
  speciesName  String
  variantName  String?
  bagSize      String?
  color        String?

  // Base price reference (not necessarily the final sale price).
  defaultPrice Decimal  @db.Decimal(18, 2)

  isActive     Boolean  @default(true)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Soft-delete for catalog integrity.
  isDeleted    Boolean  @default(false)
  deletedAt    DateTime?

  // Lines reference product variants, but can be nullable to support "external items"
  // or preserve historical documents if the variant is deleted later.
  salesNoteLines SalesNoteLine[]
  quotationLines QuotationLine[]

  @@index([speciesName, variantName])
  @@index([isDeleted])
}

model SalesNote {
  id            String          @id @default(cuid())

  // Human-friendly unique folio (generated using FolioSequence type SALES_NOTE).
  folio         String          @unique

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  // Customer reference; onDelete is Restrict to protect history.
  partyId       String
  party         Party           @relation(fields: [partyId], references: [id], onDelete: Restrict)

  status        SalesNoteStatus @default(DRAFT)

  // Totals are stored as decimals to avoid float issues.
  // subtotal / discountTotal / total should remain consistent with lines and business rules.
  subtotal      Decimal         @db.Decimal(18, 2)
  discountTotal Decimal         @db.Decimal(18, 2)
  total         Decimal         @db.Decimal(18, 2)

  // SalesNote owns its lines; deleting a note deletes lines.
  lines         SalesNoteLine[]

  // Payments attached to this note (direction IN).
  payments      Payment[]

  @@index([partyId])
  @@index([createdAt])
  @@index([status])
}

model SalesNoteLine {
  id                  String   @id @default(cuid())
  salesNoteId         String

  // Optional: allows unregistered/external products or historic preservation after deletion.
  productVariantId    String?

  // Snapshot of the item description at the time of sale.
  // IMPORTANT: do not depend on ProductVariant current name for historical views.
  descriptionSnapshot String

  // Decimal quantity supports partial units/weights.
  quantity            Decimal  @db.Decimal(18, 3)

  // Unit price and line total are stored to preserve pricing at time of transaction.
  unitPrice           Decimal  @db.Decimal(18, 2)
  lineTotal           Decimal  @db.Decimal(18, 2)

  salesNote      SalesNote      @relation(fields: [salesNoteId], references: [id], onDelete: Cascade)
  productVariant ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: SetNull)

  @@index([salesNoteId])
  @@index([productVariantId])
}

model Payment {
  id          String           @id @default(cuid())

  // Payments can be linked to a SalesNote (customer payments).
  // When a sales note is deleted (rare), keep the payment but detach it (SetNull).
  salesNoteId String?
  salesNote   SalesNote?       @relation(fields: [salesNoteId], references: [id], onDelete: SetNull)

  // Payments can be linked to a SupplierPurchase (supplier debt settlement).
  // Nullable for backwards compatibility; SetNull to preserve history if purchase is removed.
  supplierPurchaseId String?
  supplierPurchase   SupplierPurchase? @relation(fields: [supplierPurchaseId], references: [id], onDelete: SetNull)

  // Payments can also be linked directly to a Party (supplier payments or other movements).
  // We keep historical payments even if a party is soft-deleted; relation is SetNull.
  partyId     String?
  party       Party?           @relation(fields: [partyId], references: [id], onDelete: SetNull)

  direction   PaymentDirection
  paymentType PaymentType

  // amount is nullable to allow drafts or partial flows, but business logic should enforce it when saving.
  amount      Decimal?         @db.Decimal(18, 2)

  // reference can carry external identifiers (bank transfer folio)
  // and can be used as a token to link payments to SupplierPurchase if needed.
  reference   String?
  notes       String?

  occurredAt  DateTime

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([salesNoteId])
  @@index([supplierPurchaseId])
  @@index([partyId])
  @@index([occurredAt])
}

model SupplierPurchase {
  id            String   @id @default(cuid())

  // Supplier reference; onDelete Restrict to preserve purchase history.
  partyId       String

  // Supplier-provided folio/reference number (not the system folio).
  supplierFolio String

  // occurredAt is the real purchase date (can differ from createdAt).
  occurredAt    DateTime

  // Total purchase amount (debt we owe to supplier before payments).
  total         Decimal  @db.Decimal(18, 2)

  notes         String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  party Party @relation(fields: [partyId], references: [id], onDelete: Restrict)
  payments Payment[]

  @@index([partyId])
  @@index([occurredAt])
}

// Append-only audit log for key business events.
model AuditLog {
  id              String           @id @default(cuid())
  eventKey        String
  action          AuditAction

  entityType      AuditEntityType
  entityId        String

  // Root entity is the main business object affected by the event (e.g., SalesNote for its payments).
  rootEntityType  AuditEntityType?
  rootEntityId    String?

  reference       String?

  actorUserId     String?
  actorUserName   String?
  actorUserEmail  String?

  occurredAt      DateTime
  meta            Json?

  createdAt       DateTime        @default(now())
  changes         AuditLogChange[]

  @@index([rootEntityType, rootEntityId, createdAt])
  @@index([entityType, entityId, createdAt])
  @@index([eventKey, createdAt])
  @@index([actorUserId, createdAt])
}

model AuditLogChange {
  id            String         @id @default(cuid())
  auditLogId    String
  key           AuditChangeKey

  decimalBefore Decimal?       @db.Decimal(18, 2)
  decimalAfter  Decimal?       @db.Decimal(18, 2)

  stringBefore  String?
  stringAfter   String?

  jsonBefore    Json?
  jsonAfter     Json?

  createdAt     DateTime       @default(now())

  auditLog      AuditLog       @relation(fields: [auditLogId], references: [id], onDelete: Cascade)

  @@index([auditLogId])
}

model PartyLedgerEntry {
  id         String              @id @default(cuid())
  partyId    String

  // RECEIVABLE: party owes the business (e.g. SalesNote)
  // PAYABLE: business owes the party (e.g. SupplierPurchase)
  side       PartyLedgerSide

  // Source document type that created this entry (derived).
  sourceType PartyLedgerSourceType

  // ID of the source document (SalesNote.id, SupplierPurchase.id, Payment.id, etc).
  // Nullable for ADJUSTMENT or future cases.
  sourceId   String?

  // Human readable reference (folio) used for audit/traceability.
  reference  String

  // Effective date of the movement.
  occurredAt DateTime

  // Signed amount is not used; we keep amount positive and interpret meaning via side.
  amount     Decimal             @db.Decimal(18, 2)

  notes      String?
  createdAt  DateTime            @default(now())

  party Party @relation(fields: [partyId], references: [id], onDelete: Cascade)

  @@index([partyId])
  @@index([occurredAt])
  @@index([sourceType, sourceId])

  // Enforces "1 derived ledger entry per source document".
  // This makes ledger idempotent and safe to upsert from use cases.
  @@unique([sourceType, sourceId])
}

model Quotation {
  id        String          @id @default(cuid())

  // Human-friendly unique folio (generated using FolioSequence type QUOTATION).
  // IMPORTANT: Quotations do NOT generate ledger entries directly.
  folio     String          @unique

  // Contact/party for the quotation (customer or lead stored as Party).
  partyId   String

  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  status    QuotationStatus @default(DRAFT)

  // Total can be stored to optimize reads; should be kept consistent with lines.
  // Nullable to allow drafts during migration; business logic should compute it.
  total     Decimal?        @db.Decimal(18, 2)

  party Party @relation(fields: [partyId], references: [id], onDelete: Restrict)

  // Quotation owns its lines; deleting quotation deletes lines.
  lines QuotationLine[]

  @@index([partyId])
  @@index([createdAt])
  @@index([status])
}

model QuotationLine {
  id                  String   @id @default(cuid())
  quotationId         String

  // Optional, supports external/manual line items or historical preservation.
  productVariantId    String?

  // Snapshot of the item description at the time of quoting.
  descriptionSnapshot String

  quantity            Decimal  @db.Decimal(18, 3)

  // Quoted unit price (does not have to match ProductVariant.defaultPrice).
  quotedUnitPrice     Decimal  @db.Decimal(18, 2)

  quotation      Quotation      @relation(fields: [quotationId], references: [id], onDelete: Cascade)
  productVariant ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: SetNull)

  @@index([quotationId])
  @@index([productVariantId])
}

model FolioSequence {
  id         String    @id @default(cuid())

  // Folio type (e.g. SALES_NOTE, QUOTATION)
  type       FolioType

  // Sequence is partitioned by year and month to keep folios readable and reset monthly.
  year       Int
  month      Int

  // Next number to use within (type, year, month)
  nextNumber Int

  // Ensures there is a single sequence row per month per folio type.
  @@unique([type, year, month])
}
