import { prisma } from "@/lib/prisma";
import { toNumber } from "@/modules/shared/utils/toNumber";
import { z } from "zod";
import { excludeSoftDeleted } from "@/modules/shared/queries/softDeleteHelpers";

const InputSchema = z.object({
  asOf: z.date(),
});

export type ReceivablesBucketDto = {
  label: "0-7" | "8-15" | "16-30" | "31+";
  amount: number;
};

export type DashboardReceivablesSummaryDto = {
  asOf: string; // ISO
  totalReceivable: number; // sum of positive balances across customers
  buckets: ReceivablesBucketDto[]; // based on SALES_NOTE receivables aging
};

function bucketLabel(days: number): ReceivablesBucketDto["label"] {
  if (days <= 7) return "0-7";
  if (days <= 15) return "8-15";
  if (days <= 30) return "16-30";
  return "31+";
}
export async function getDashboardReceivablesSummary(input: {
  asOf: Date;
}): Promise<DashboardReceivablesSummaryDto> {
  const { asOf } = InputSchema.parse(input);

  // 1) Identify customer parties (soft-delete safe).
  const customerPartyRows = await prisma.partyRole.findMany({
    where: {
      role: "CUSTOMER",
      party: { isDeleted: false },
    },
    select: { partyId: true },
  });

  const customerPartyIds = Array.from(
    new Set(customerPartyRows.map((x) => x.partyId))
  );

  if (customerPartyIds.length === 0) {
    return {
      asOf: asOf.toISOString(),
      totalReceivable: 0,
      buckets: [
        { label: "0-7", amount: 0 },
        { label: "8-15", amount: 0 },
        { label: "16-30", amount: 0 },
        { label: "31+", amount: 0 },
      ],
    };
  }

  // 2) Net balance per customer: sum(RECEIVABLE) - sum(PAYABLE)
  // ✅ IMPORTANTE: Solo contar entradas activas del ledger
  const sums = await prisma.partyLedgerEntry.groupBy({
    by: ["partyId", "side"],
    where: {
      partyId: { in: customerPartyIds },
      ...excludeSoftDeleted, // ← Filtrar entradas eliminadas
    },
    _sum: { amount: true },
  });

  // Fixed Map declaration syntax
  const balanceByParty = new Map<
    string,
    { receivable: number; payable: number }
  >();

  for (const row of sums) {
    const cur = balanceByParty.get(row.partyId) ?? {
      receivable: 0,
      payable: 0,
    };
    const amount = toNumber(row._sum.amount);

    if (row.side === "RECEIVABLE") cur.receivable += amount;
    else cur.payable += amount;

    balanceByParty.set(row.partyId, cur);
  }

  let totalReceivable = 0;
  for (const [_, v] of balanceByParty.entries()) {
    const balance = v.receivable - v.payable;
    if (balance > 0) totalReceivable += balance;
  }

  // 3) Aging buckets (simple): based on SALES_NOTE receivables entries.
  // This answers: "How old is the debt generated by sales notes?"
  // ✅ IMPORTANTE: Solo contar entradas activas
  const receivableEntries = await prisma.partyLedgerEntry.findMany({
    where: {
      partyId: { in: customerPartyIds },
      side: "RECEIVABLE",
      sourceType: "SALES_NOTE",
      ...excludeSoftDeleted, // ← Filtrar entradas eliminadas
    },
    select: {
      occurredAt: true,
      amount: true,
    },
  });

  const bucketsMap: Record<ReceivablesBucketDto["label"], number> = {
    "0-7": 0,
    "8-15": 0,
    "16-30": 0,
    "31+": 0,
  };

  const asOfMs = asOf.getTime();

  for (const e of receivableEntries) {
    const days = Math.max(
      0,
      Math.floor((asOfMs - e.occurredAt.getTime()) / 86400000)
    );
    const label = bucketLabel(days);
    bucketsMap[label] += toNumber(e.amount);
  }

  const buckets: ReceivablesBucketDto[] = [
    { label: "0-7", amount: bucketsMap["0-7"] },
    { label: "8-15", amount: bucketsMap["8-15"] },
    { label: "16-30", amount: bucketsMap["16-30"] },
    { label: "31+", amount: bucketsMap["31+"] },
  ];

  return {
    asOf: asOf.toISOString(),
    totalReceivable,
    buckets,
  };
}
